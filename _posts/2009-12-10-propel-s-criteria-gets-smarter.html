---
layout: post
title: Propel's Criteria Gets Smarter
published: true
---
<p>I've always been frustrated with Propel's Criteria. Despite its powerful Object-Oriented API for querying a database, I find it quite dumb and very hard to learn. It used to be one of Propel's main drawbacks. But starting with Propel 1.5, you can count on the Criteria to be much smarter.<p /> <strong>Criteria's Shortcomings<br /></strong> <br />Let me be more specific. The Criteria object doesn't know about your model schema, and forces you to repeat both the members of a relation each time you write a join:<p />[code]
$c = new Criteria();
 $c-&gt;addJoin(BookPeer::AUTHOR_ID, AuthorPeer::ID);
[/code]<p />With a Criteria, you can't write queries that make two joins on the same table. You can't easily write a custom SQL clause that will use proper binding.<br /> <!--more--><br />Criteria also follows a syntax that you cannot guess, so you need the Criteria API documentation open at all times for months until you can figure out that kind of snippet:<p />[code]
$c = new Criteria();
 $c1 = $c-&gt;getNewCriterion(BookPeer::TITLE, '%Leo%', Criteria::LIKE);
$c2 = $c-&gt;getNewCriterion(BookPeer::ISBN, '1234', Criteria::EQUAL);
$c1-&gt;addOr($c2);
$c-&gt;add($c1);
$c-&gt;addAscendingOrderByColumn(BookPeer::CREATED_AT);
 [/code]<p />After giving several trainings for Propel, I keep on seeing developers struggle to write a simple query. Propel's Criteria is definitely one of its less intuitive features, and it's not the most powerful query API in the world either.<p /> <strong>Criteria's Power</strong><p />I already tried to address these shortcomings a year and a half ago, through a plugin for the Symfony framework called <a href="http://www.symfony-project.org/plugins/DbFinderPlugin">DbFinder</a>. With DbFinder, it became a pleasure to develop model code based on Propel, and to teach how to use it.<p /> DbFinder relied heavily on Criteria, but added a lot of custom code. Some of this code was required to do runtime introspection of the model struture. Propel 1.4 recently introduced the RelationMap classes, and the ability for a model to know all its relations at runtime. This was the first brick for a native implementation of DbFinder in Propel.<p /> Building DbFinder abilities right into Propel Criteria was the next step, but the Propel implementation had to differ from DbFinder's one. There is one thing that I have understood in the past months, and it's the biggest strength of Propel: the fact that Propel can generate objects at buildtime is what makes it faster than all its competitors. So I used Propel's generator in conjunction with DbFinder's power to create the ModelCriteria class and the PropelQuery factory.<p /> By initializing a Criteria object with a Model name, it is now possible to write queries in the following way:<p />[code]
$books = PropelQuery::from('Book b')
&nbsp; -&gt;join('b.Author a')
 &nbsp; -&gt;where('a.FirstName = ?', 'Leo')
&nbsp; -&gt;orderBy('b.Title')
&nbsp; -&gt;limit(10)
&nbsp; -&gt;find();
[/code]<p />Behind this `PropelQuery`, it's the same old Criteria at work. That means that this new syntax is entirely backwards compatible. You can see it as a usability layer on top of Criteria, that doesn't break any existing application. The new syntax is already committed to the Propel 1.5 branch, fully unit tested, and documented in a <a href="http://propel.phpdb.org/trac/wiki/Users/Documentation/1.5/ModelCriteria">brand new documentation chapter</a>.<p /> <strong>There Is One Way To Do It<br /></strong><br />You probably understood that this new syntax can completely replace the use of Peer classes in Propel. But for the time being, that means that there are two ways to write and execute a query with Propel. The old way, using Criteria and Peer classes, and the new way, using PropelQuery. <p /> And it's a good usability guideline not to leave too much choice to avoid that users get lost.<p />The old way has to be there for backwards compatibility. It will remain the in the Propel core for as long as the Propel 1.x branch lives.<p /> The new way will become the default way some time in the future - maybe in time for the 1.5 release. That will mean a large rewrite of the current documentation and behaviors, but it's not such a big task. More specifically, the main documentation will omit the Criteria and Peer way. But rest assured, the cookbook will still provide a chapter to learn how to run them.<p /> <strong>Propel Is Not Becoming Doctrine</strong><p />I know what most Propel old timers will think of this addition: this is Propel becoming Doctrine and giving away its soul to the new ORM golden boy. Well, in a way, I agree with that. This new feature takes some of the recipes that proved successful in Doctrine, and that Doctrine took from other projects beforehand. This is called Open-Source cross-pollinisation. Reusing the best ideas found elsewhere is not losing one's soul. What makes Propel's soul is its ability to query a database through an object-oriented API. This is still there, and better than ever.<p /> Now the new Propel Query API has some significant differences with Doctrine's Query API. First of all, it is faster. Propel still relies on generated code to execute queries in roughly half the time Doctrine needs. Propel's queries don't need a Parser/Lexer implementation, because they only accept simple clauses, described in a standard way. By combining these simple clauses, you can write very complex queries. Also, you can extend Propel Query objects to write Named Queries, which are objects embedding a query for later reuse. This will be the true revolution in your development habits. Your model code will be more readable, more maintainable, and more robust than ever.<p /> <strong>Propel's Future<br /></strong><br />One last word: This new feature is not particularily aimed at current Propel users. You guys already master the Criteria, you have Criteria all over your application code, and you will be able to use its seamlessly until the 1.x branch dies. If you want to ignore the new Propel Query features, then go on as before and don't worry about it - it won't interfere with your code.<p /> But newcomers who have to choose an ORM nowadays have basically two choices, and I don't want them to ignore Propel for the wrong reasons. The poor usability of Propel's Criteria used to be a reason for not choosing Propel. It should no longer be the case.<p /> So as of now, Propel is a very usable ORM. Make sure you spread the word.</p>
