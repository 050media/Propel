---
layout: post
title: If your model classes are empty, you didn't get the best of ORM
published: true
---
<p>I see a lot of projects carrying very lightweight model classes: the stub ActiveRecord and Query classes generated by Propel remain empty after a while. This is not only a sign that the developers put the code in the wrong place, but also that they still don&rsquo;t get a grasp of the ORM paradigm. Let&rsquo;s see a few examples that illustrate that.</p>

<h3>The ActiveRecord Classes Are Where The Record Manipulation Should Be</h3>

<p>In a phone book application, a Person has a first name, a last name, a gender, and a marital status. In the view layer of the application, the developer wrote a helper function that displays a Person&rsquo;s identity, which applies a few presentation rules according to the available data:</p>

<div class="CodeRay">
  <div class="code"><pre>function getPersonIdentity($person)
{
  if ($gender = $person-&gt;getGender()) {
    if (strtolower($gender) == 'male') {
      $title = 'Mr.';
    } else {
       if ($person-&gt;getMaritalStatus() == 'married') {
         $title = 'Mrs.';
       } else { 
         $title = 'Miss';
       }
    }
  } else {
    $title = '';
  }
  if ($person-&gt;getFirstName() &amp;&amp; $person-&gt;getLastName()) {
    return $title . $person-&gt;getFirstName() . ' ' . $person-&gt;getLastName();
  } elseif ($person-&gt;getLastName()) {
    return $title . $person-&gt;getLastName();
  } elseif ($person-&gt;getFirstName()) {
    return $title . $person-&gt;getFirstName();
  } else {
    return 'Mr. Nobody';
  }
}</pre></div>
</div>


<p>This helper function could be broken down into several smaller functions to increase reusability. For instance, the line that determines the title of a person could be turned into a standalone <code>getTitle()</code> function:</p>

<div class="CodeRay">
  <div class="code"><pre>function getTitle($person)
{
  if(!$gender = $person-&gt;getGender()) {
    return false;
  }
  if (strtolower($gender) == 'male') {
    return 'Mr.';
  } else {
     if ($person-&gt;getMaritalStatus() == 'married') {
       return 'Mrs.';
     } else { 
       return 'Miss';
     }
  }
}</pre></div>
</div>


<p>In this last function, the line that determines if a woman is married could also be isolated:</p>

<div class="CodeRay">
  <div class="code"><pre>function isMarried($person)
{
  return $person-&gt;getMaritalStatus() == 'married';
}</pre></div>
</div>


<p>Note that this piece of code can now be reused for men, while it was only used to determine if a woman was married or not.</p>

<p>The process of isolating functions is good for reusability, but quite bad for code maintenance. All these standalone helper functions pollute the global namespace, and even if they are in a common helper file, they don&rsquo;t share anything in common with each other. Or do they?</p>

<p>They actually share one important thing: their parameter, a Person instance. This should ring a bell and draw your attention to the ActiveRecord model classes. With a little refactoring, the first helper function can be entirely moved into the Person class, to make it fully reusable &ndash; including in parts of the application that don&rsquo;t have access to the helper functions of the view layer:</p>

<div class="CodeRay">
  <div class="code"><pre>class Person extends BasePerson
{
  const SINGLE = 'single';
  const MARRIED = 'married';

  public function hasMaritalStatus()
  {
    return null !== $this-&gt;getMaritalStatus();
  }

  public function isMarried()
  {
    return $this-&gt;getMaritalStatus() == self::MARRIED;
  }

  public function isSingle()
  {
    return !$this-&gt;isMarried();
  }

  const FEMALE = 'female';
  const MALE = 'male';

  public function hasGender()
  {
    return null !== $this-&gt;getGender();
  }

  public function isFemale()
  {
    return strtolower($this-&gt;getGender()) == self::FEMALE;
  }

  public function isMale()
  {
    return !$this-&gt;isFemale();
  }

  public function getTitle()
  {
    if(!$this-&gt;hasGender()) {
      return false;
    }
    if ($this-&gt;isMale()) {
      return 'Mr.';
    } else {
       if (!$this-&gt;hasMaritalStatus() || $this-&gt;isMarried()) {
         return 'Mrs.';
       } else { 
         return 'Miss';
       }
    }
  }

  public function getFullName()
  {
    if ($this-&gt;getFirstName() &amp;&amp; $this-&gt;getLastName()) {
      return $this-&gt;getFirstName() . ' ' . $this-&gt;getLastName();
    } elseif ($this-&gt;getLastName()) {
      return $this-&gt;getLastName();
    } elseif ($this-&gt;getFirstName()) {
      return $false-&gt;getFirstName();
    } else {
      return false;
    }
  }

  const UNKOWN_NAME = 'Mr. Nobody';

  public function getIdentity()
  {
    if (!$fullName = $this-&gt;getFullName()) {
      return self::UNKOWN_NAME;
    }
    if ($title = $person-&gt;getTitle()) {
      return $title . ' ' . $fullName;
    } else {
      return $fullName;
    }
  }
}</pre></div>
</div>


<p>That&rsquo;s a lot of new methods, but now they are bundled together into a single place, and this is where they belong. The developer can unit test them, and reuse them very easily across all the application.</p>

<p>These new methods make the code much easier to read. Even if you don&rsquo;t know how the gender is stored in the database, you can use the <code>isMarried()</code> method. In practice, these methods abstract the storage structure, and offer an easy-to-use interface to the stored data.</p>

<p>This refactoring to the ActiveRecord class is a pretty basic OOP technique, but many developers tend to oversee it. Some of them come to ORMs with a simple PHP background, and they are not used to spotting which code is part of the model. Some others take the ORM classes as a place to put database queries and nothing else.</p>

<h3>The Query Classes Are Where The Queries Should Be</h3>

<p>In a CMS application, a Section has many Articles. In order to display the list of latest articles, the developer wrote a <code>getPublishedArticles()</code> in the <code>Section</code> ActiveRecord class:</p>

<div class="CodeRay">
  <div class="code"><pre>class Section extends BaseSection
{
  public function getPublishedArticles()
  {
    return ArticleQuery::create()
      -&gt;filterBySection($this)
      -&gt;filterByPublishedAt(array('max' =&gt; time())
      -&gt;orderByPublishedAt('desc')
      -&gt;find();
  }
}</pre></div>
</div>


<p>But the piece of logic that determines if an article is published or not must be repeated to <em>count</em> the published articles. Or, it could be required in another model, for instance to find the published articles <em>by an author</em>. Therefore, this piece of logic should be written in the <code>ArticleQuery</code> class. After all, it&rsquo;s an Article filter:</p>

<div class="CodeRay">
  <div class="code"><pre>class ArticleQuery extends BaseArticleQuery
{
  public function published()
  {
    return $this-&gt;filterByPublishedAt(array('max' =&gt; time());
  }
}</pre></div>
</div>


<p>This new method already shows a great virtue : you can unit test it. Also, it has a meaningful name, that expresses domain logic rather than storage logic. Imagine if the <code>published_at</code> column was named <code>art_pub_date</code>, and you will get a better idea of the benefit of a meaningful name.</p>

<p>Now the ActiveRecord method is easier to write and read:</p>

<div class="CodeRay">
  <div class="code"><pre>class Section extends BaseSection
{
  public function getPublishedArticles()
  {
    return ArticleQuery::create()
      -&gt;filterBySection($this)
      -&gt;published()
      -&gt;orderByPublishedAt('desc')
      -&gt;find();
  }
}</pre></div>
</div>


<p>The developer should even go further and package all the filtering logic into the Query class:</p>

<div class="CodeRay">
  <div class="code"><pre>class ArticleQuery extends BaseArticleQuery
{
  public function published()
  {
    return $this-&gt;filterByPublishedAt(array('max' =&gt; time());
  }

  public function recent()
  {
    return $this-&gt;orderByPublishedAt('desc');
  }

  public function recentlyPublished()
  {
    return $this-&gt;recent()-&gt;published();
  }
}</pre></div>
</div>


<p>Also, the generated <code>BaseSection::getArticles()</code> method already filters by the current Section, and terminates the query: these pieces of code should be reused rather than rewritten. And since the generated Foreign Key getters accept a Query object as parameter, you could write the <code>getPublishedArticles()</code> method in a single line:</p>

<div class="CodeRay">
  <div class="code"><pre>class Section extends BaseSection
{
  public function getPublishedArticles()
  {
    return $this-&gt;getArticles(ArticleQuery::create()-&gt;recentlyPublished());
  }
}</pre></div>
</div>


<p>So what happened here? The ActiveRecord class got stripped of most of its code in favor of the Query class. And the ActiveRecord class no longer manipulates columns. It deals with expressive filters rather than database conditions.</p>

<p>Here is a good rule of thumb: If you&rsquo;re using <code>filterByXXX()</code>, <code>orderByXXX()</code>, <code>useXXXQuery()</code>, or <code>find()</code> in an ActiveRecord class, you should probably move some code to the Query class. Your ActiveRecord classes should only use meaningful filters, and let the Query classes offer reusability and testability to filtering logic.</p>

<h3>The Model Classes Are Where The Model Logic Should Be</h3>

<p>Breaking down large methods is just an OOP technique that favors reusability. Moving methods to the model classes is just an OOP technique to package code in a logical way. But there is more to ORMs than simple programming techniques.</p>

<p>The result of the refactorings illustrated in this post is a set of classes that <em>carry domain logic</em>. They translate a set of rules &ndash; how to form a title, how to extract published articles &ndash; into simple methods with expressive names. Names that even the final customer can understand.</p>

<p>The refactorings actually ended up into an API to the project&rsquo;s domain logic. This is what make a true Domain Model.</p>

<p>After a while, developers who repeat this kind of refactoring change their coding habits. They don&rsquo;t start with data in a table with a PHP interface ; instead, they start by designing an object model to the customer&rsquo;s domain. They see the database storage of domain objects as a simple consequence of a need for persistence.</p>

<p>An ORM is just a set of tools helping developers to write their domain logic more easily. Don&rsquo;t let the relational databases get in your way; think Object-Oriented Programming, and embrace the Domain-Driven Design paradigms.</p>
